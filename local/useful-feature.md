# Git 学习中发现的一些有趣的功能

在使用 git 的时候看到一些很少使用，但觉得用起来非常有帮助的功能。

[TOC]

## 独享式忽略

在实际的项目开发中，有些功能或者语言的特性并不是十分清楚，或者自己有一些新的想法，但是不确定。我们总会自己写一些代码验证一下，如果是简单的语言特性，直接 `PHP -a` 在交互环境或者编写个小文件测试就行了。如果是一些跟框架有关的东西，要写个文件，我们要单独建立一个项目测试吗？其实不用那么麻烦，直接在项目中写就行。但是这样之后又需要吧这些文件删掉，有时候一些测试还是有一些参考价值的。这是后就要用到 `git` 的忽略特性了。

在 git 仓库中，我们常常使用 `.gitignore` 忽略一些文件，不希望它在版本库中记录。我们也可以把测试文件都当道一个目录下，然后忽略掉。然而 `.gitignore` 中添加的忽略都是跟项目有关的，为了忽略几个个人测试文件添加忽略规则有些不够优雅。其实 `git` 还提供了一个“独享式”的忽略，它并不会像 `.gitignore` 一样同步到远端，进在本地有效。

### 独享式忽略添加

在仓库中有个 `.git/info/exclude` 文件，这个文件就是独享式的忽略文件，添加的忽略规则和 `.gitignore` 一样。例如我添加一个新的目录 ‘api/myTest’。

只需要添加内容

```
/api/myTest
```


- `/api/myTest` 忽略的根目录就是是 `git` 仓库的根目录（即 .git 文件夹所在的位置）。并不是操作系统的下的 `/api/myTest`
- 独享式的目录最好看起来跟个人有关，比如 `myTest`，甚至是 ‘<your-name>-test’。这样不容易和项目中的文件夹相混淆。不然，万一别人新建的文件夹，从远程拉下来代码，恰好是本地忽略的，这就很尴尬了。
- 其实 `.gitignore` 不仅可以在仓库的根目录，在任何工作区的目录下都可以添加 `.gitignore` 文件。忽略的路径是当前 `.gitignore` 所在的目录。

**我想还有更多用处可以探索**

## 完全独立的分支

在使用git进行版本控制的某些场景中我们可能需要在一个项目中建立完全独立的分支，此分支将作为一个独立的版本历史根节点，不与之前任何分支拥有相同的版本祖先。

比如当我们要在一个项目中使用一个分支进行项目文档的管理时，或者当我们想要发布一个软件的开源版本但又不希望将软件的版本历史暴露给外界时，都可以使用以下的方法建立一个独立分支。
通过带orphan参数的checkout命令建立独立分支

通过带有–orphan参数的checkout命令即可从start_point或者HEAD创建一个独立分支
```
$cd repo
$git checkout --orphan 新分支名 <start_point>
```

创建全新的独立分支

如果希望创建全新的独立分支，例如用于文档管理，不想出现项目代码，则还需要进行如下删除操作
注意如果有不在索引中的文件，则需要手工删除(包括.gitignore)

删除此分支中的索引及索引中的所有文件
```
$ git rm -rf .
```

然后从新建立文件和提交。

## 使用 git 用于定位bug

这个我还没使用过。但是觉得有时候会起到一个特别的作用。比如上次 `coupon` 项目出现的内存占用过高，是不是可以使用这种方法定位是不是代码的问题？

git 的二分查找是建立在测试的基础之上的（有前提条件的），即确定之前的某个版本是好的，在最近的版本中出现了问题。但是又不确定是哪个功能引起的。这样可以肯定的是：在之前的哪个版本和当前版本之间的某个版本出了问题。如果所发现的错误在最早的版本中都是错误的，那就只能老老实实 `debug` 了。

如果真的是代码的问题，定位最快的方式就是在版本间进行二分查找。取好的版本和当前版本之间的一个版本。回退到中间的这个版本，如果该版本是好的，则，问题出现之后的版本中，如果中间的版本也有问题，则问题出现在之前的版本中。git 为这套回退测试提供了自动机制。


### git bisect 二分查找

1. 工作区切换到已知的 “好版本” 和 “坏版本” 之间的一个版本。
2. 执行测试，如果问题出现，则将当前版本标记为 “坏版本”， 如果问题没有出现，则将当前版本标记为 “好版本”。
3. 重复 1~2，直到找到第一个引起该问题的版本。


### 查找过程

确定好当前所在的分支后就可以查找了。

1. 开始二分查找
```
$ git bisect start
```

2. 标记最初的查找区间。将当前版本 `HEAD` 标记为 “坏提交”，将之前的确定好的版本标记为 “好提交”.
```
$ git bisect bad
$ git bisect good <branch_id/tag>
```
标记指定版本可以使用版本 id 或 tag。

3. 自动定位到中间版本。
```
$ git describe
```

4. 执行测试。如果该版本是正常的，只需要执行
```
$ git bisect good
```
如果版本有问题
```
$ git bisect bad
```
这会自动标记当前版本，因为缺省指定版本是，指向的就是 `HEAD` 指向的版本。

5. 重复以上的 3 ~ 4 直到定位到最终的出错版本。git 会在查找到终点是使用 `bisect/bad` 引用最终的坏版本。可以使用如下的命令检出有问题的版本，并修复。

```
$ git checkout bisect/bad
```

6. 在修复好后，撤销二分查找在版本库中遗留的临时文件和引用。撤销二分查找后，版本库自动切回到查找之前所在的分支。

```
$ git bisect reset
```

### 把 “好提交” 标记为 “坏提交” 了怎么办

如果在执行查找过程中，将 “好提交” 标记为 “坏提交”了，或者相反。不要着急，工作并不会前功尽弃。`git` 早已为愚蠢的人类准备好了应对措施。

1. 例如，对于版本提交 E，本来是一个好版本，却被标记成了坏版本。
```
$ git bisect bad
```
 
2. 用 `bisect log` 查看二分查找的记录
```
$ git bisect log > logfile
```

3. 编辑这个文件，删除记录了错误的行。（以 # 开始的行是注释）

4. 结束正在进行的出错的二分查找
```
$ git bisect reset
```

5. 通过日志恢复进度，重启二分查找

```
$ git bisect replay logfile
```

6. 再次回到了 E 节点，就可以重新标记了。

```
$ git describe
E
$ git bisect good
```

### 二分查找使用自动化测试脚本

git 的二分查找支持 run 子命令，可以运行一个自动化测试脚本，实现自动的二分查找。

- 如果脚本的退出码是0，则正在测试的版本会被标记为 “好版本”
- 如果脚本的退出码是125，则正在测试的版本会被跳过
- 如果脚本的退出码是1 ~ 127 除 125 外，则正在测试的版本会被标记为 “坏版本”

1. 首先就是要标记执行测试的开始版本区间，如标记 master为 “坏版本”，标记 G 为 “好版本”。除了上面的分步标记外，也可以一步完成
```
$ git bisect start master G
```

2. 执行自动化测试脚本，加入测试脚本文件是 `test.sh`

```
$ git bisect run bash test.sh
```

3. 如果脚本正常执行，执行结束后，就可以切换到出错的版本。

```
$ git checkout bisect/bad
```


## 定位文件编辑者

在以上的追踪到响应的问题代码后，或者其他方式发现问题代码后，git 提供了一个快速定位内容编辑者的子命令 `blame`


使用 blame （归咎于）子命令可以查看某文件的修改记录，并且显示修改版本，用户和时间信息。

如果你要查看文件的每个部分是谁修改的，那么 git blame 就是不二选择. 只要运行git blame [filename]，你就会得到整个文件的每一行的详细修改信息：包括SHA串，日期和作者。

你也可以用"-L"参数在命令(blame)中指定开始和结束行:

```
$ git blame -L 160,+10 sha1_file.c
ace1534d (Junio C Hamano 2005-05-07 00:38:04 -0700       160)}
...
```

-L 的参数可以写两个行， 例如 12,13 表示 12 行和 13 行的内容。
还可以使用 + 表示向后取 n 行。

如果只关系谁修改成了什么内容。 可以使用 grep 截取。
